from sklearn.model_selection import train_test_split
import numpy as np
import joblib
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import itertools
import pandas as pd
from tensorflow.keras import Input


##################################################################################################################################
                                                         CARREGA OS DADOS

# 1) Carregar dados
X = np.load('X_normalizado.npy')
y = np.load('y_saida.npy')

# Garantir que y seja 2D: (n amostras, n_saidas)
if y.ndim == 1:
    y = y.reshape(-1, 1)

# 2) Normalizar y e salvar scaler
scaler_y = StandardScaler()
y_normalizado = scaler_y.fit_transform(y)
joblib.dump(scaler_y, 'scaler_y.pkl')
print("Scaler de y salvo como 'scaler_y.pkl'.")

# 3) Split
X_temp, X_test, y_temp, y_test = train_test_split(
    X, y_normalizado, test_size=0.15, random_state=42
)
X_train, X_val, y_train, y_val = train_test_split(
    X_temp, y_temp, test_size=0.1765, random_state=42
)

# Salvar conjuntos
np.save('X_train.npy', X_train)
np.save('X_val.npy',   X_val)
np.save('X_test.npy',  X_test)
np.save('y_train.npy', y_train)
np.save('y_val.npy',   y_val)
np.save('y_test.npy',  y_test)
print("Conjuntos de dados salvos com sucesso.")

##################################################################################################################################
                                                            GRID SEARCH 


ativacoes  = ['linear', 'relu', 'tanh']
neurons    = [32, 64, 128, 256, 512]
num_layers = [1, 2, 3, 4, 5]

resultados = []
best_mae_real = np.inf  # para salvar o melhor modelo por MAE real
scaler_y = joblib.load('scaler_y.pkl')

for ativacao, n_neuronios, camadas in itertools.product(ativacoes, neurons, num_layers):
    print(f"\nüîß Testando: ativa√ß√£o={ativacao}, neur√¥nios={n_neuronios}, camadas={camadas}")

    # Modelo
    modelo = Sequential()
    modelo.add(Input(shape=(X_train.shape[1],)))
    modelo.add(Dense(n_neuronios, activation=ativacao))
    for _ in range(camadas - 1):
        modelo.add(Dense(n_neuronios, activation=ativacao))
    modelo.add(Dense(y_train.shape[1], activation='linear'))

    # Treinar APENAS com MAE
    modelo.compile(optimizer='adam', loss='mae', metrics=['mae'])

    es = EarlyStopping(monitor='val_loss', patience=15, restore_best_weights=True)

    modelo.fit(
        X_train, y_train,
        validation_data=(X_val, y_val),
        epochs=200,
        batch_size=32,
        callbacks=[es],
        verbose=0
    )

    # Avalia√ß√£o em escala normalizada
    loss_mae_norm, mae_norm = modelo.evaluate(X_test, y_test, verbose=0)

    # Predi√ß√£o e m√©tricas em ESCALA REAL (desnormalizada)
    y_pred_norm = modelo.predict(X_test, verbose=0)
    y_pred_real = scaler_y.inverse_transform(y_pred_norm)
    y_test_real = scaler_y.inverse_transform(y_test)

    # MAE real
    mae_real = mean_absolute_error(y_test_real, y_pred_real)
    # RMSE real
    rmse_real = np.sqrt(mean_squared_error(y_test_real, y_pred_real))
    # R¬≤ (m√©dio entre sa√≠das, se multivariado)
    r2 = r2_score(y_test_real, y_pred_real, multioutput='uniform_average')

    print(f"MAE (norm): {mae_norm:.6f} | MAE (real): {mae_real:.6f} | RMSE (real): {rmse_real:.6f}")

    resultados.append({
        'ativacao': ativacao,
        'neur√¥nios': n_neuronios,
        'camadas': camadas,
        'mae_normalizado': mae_norm,
        'mae_real': mae_real,
        'rmse_real': rmse_real,
    })


# DataFrame e ordena√ß√£o
df = pd.DataFrame(resultados)

##################################################################################################################################
                                                            COMPARA 

# Ordenar por MAE real (asc), depois RMSE (asc)
df = df.sort_values(by=['mae_real', 'rmse_real'], ascending=[True, True, False])

print("\nüìä Top 10 modelos (por MAE real, desempate por RMSE):")
print(df.head(10))

df.to_csv('resultados_comparativos.csv', index=False)
print("Resultados salvos em 'resultados_comparativos.csv'.")
